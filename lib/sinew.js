// Generated by CoffeeScript 1.6.3
(function() {
  (function() {
    var Sinew, environment, _isServer, _moduleAvailable, _setEnvironment, _windowAvailable;
    _moduleAvailable = typeof module !== "undefined";
    _windowAvailable = typeof window === "object";
    _isServer = _moduleAvailable && !_windowAvailable;
    _setEnvironment = _isServer ? "server" : "client";
    environment = {
      isServer: function() {
        return _setEnvironment === "server";
      },
      isClient: function() {
        return _setEnvironment === "client";
      }
    };
    Sinew = function(options) {
      var extend, makeNew, self;
      makeNew = function(object, Constructor) {
        if ((typeof object === 'undefined') || (object === null)) {
          throw new TypeError("Expected object as first parameter.");
        }
        if (typeof Constructor !== 'function') {
          throw new TypeError("Expected Constructor to be a function.");
        }
        if ((object instanceof Constructor) === false) {
          object = new Constructor();
        }
        return object;
      };
      self = makeNew(this, Sinew);
      self._defaults = {
        filter: function(property) {
          return property.substr(0, 1) !== '_';
        },
        pawnClientOnly: true
      };
      /**
      Filter the keys of a given object using the self._options.filter
      @method _filterProperties
      @param {Object} ofObject
      */

      self._filterProperties = function(ofObject) {
        var element, filter, result, value;
        filter = self._options.filter;
        if (ofObject === self) {
          filter = self._defaults.filter;
        }
        result = (function() {
          var _results;
          _results = [];
          for (element in ofObject) {
            value = ofObject[element];
            if (filter(element)) {
              _results.push(element);
            }
          }
          return _results;
        })();
        return result;
      };
      /**
      Create a shell object with privatized functions
      @method _publicize
      @param {Object} object
      */

      self._publicize = function(object) {
        var copy, filteredProps, prop, publicObject, _i, _len;
        filteredProps = self._filterProperties(object);
        publicObject = {};
        copy = function(name) {
          publicObject[name] = object[name];
        };
        for (_i = 0, _len = filteredProps.length; _i < _len; _i++) {
          prop = filteredProps[_i];
          copy(prop);
        }
        return publicObject;
      };
      /**
      Add a property to an object context, and create a noConflict
      method on said property if the property previously existed
      @method pawn
      @param {String} name
      @param {Object} object
      @param {context} object
      */

      self.pawn = function(name, object, context) {
        var definition;
        if (context == null) {
          context = null;
        }
        if (self._options.pawnClientOnly && environment.isServer()) {
          return false;
        }
        if (typeof name !== 'string') {
          throw new TypeError("Expected pawn's name to be string.");
        }
        if ((typeof object !== 'object') || (object === null)) {
          throw new TypeError("Expected pawn's definition to be object.");
        }
        if ((typeof context === 'object') && (context === null)) {
          context = window;
        }
        if (typeof context !== 'object') {
          throw new TypeError("Expected pawn's new context to be object.");
        }
        definition = {
          prior: null
        };
        if (typeof context[name] !== 'undefined') {
          definition.prior = context[name];
        }
        context[name] = object;
        if (definition.prior !== null) {
          object.noConflict = function() {
            var release;
            release = context[name];
            context[name] = definition.prior;
            delete release.noConflict;
            return release;
          };
        }
        return true;
      };
      self.makeNew = makeNew;
      self.forceNew = self.makeNew;
      /**
      Create a privatized object, and auto-enforce new keyword on construction
      @method create
      @alias setup
      @param {Object} object
      @param {Function} Constructor
      */

      self.setup = self.create = function(object, Constructor) {
        var e, publicizedObject;
        if (object == null) {
          object = null;
        }
        if (Constructor == null) {
          Constructor = null;
        }
        try {
          object = self.makeNew(object, Constructor);
          publicizedObject = self._publicize(object);
          return publicizedObject;
        } catch (_error) {
          e = _error;
          console.warn("Error during structured instantiation: ", e);
          console.log("Object Reference: ", object);
          throw e;
        }
      };
      extend = function(x, y) {
        var property, value;
        for (property in y) {
          value = y[property];
          x[property] = value;
        }
        return x;
      };
      /**
      Construct our sinewy object
      @method _construct
      @private
      @param {Object} opts
      */

      self._construct = function(opts) {
        var defaults, privateObject;
        defaults = extend({}, self._defaults);
        options = extend(defaults, opts);
        if (typeof options.filter !== 'function') {
          throw new TypeError("Expected options.filter to be a function.");
        }
        if (typeof options.filter('test') !== 'boolean') {
          throw new Error("Expected options.filter to give a boolean response.");
        }
        self._options = options;
        privateObject = self.create(self, Sinew);
        return privateObject;
      };
      return self._construct(options);
    };
    return module.exports = Sinew;
  })();

}).call(this);
